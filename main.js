/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DynamicFolderDash
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  hideFolderContents: false,
  viewType: "simple-list",
  includeFrontmatter: false,
  showFileCreationDate: false,
  showFileModificationDate: false,
  customCSS: "",
  triggerMode: "command-only",
  hideNotesInExplorer: true
};
var DynamicFolderDashSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Dynamic Folder Dashboard Settings" });
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Hide folder note .md file in sidebar").setDesc("When enabled, the folder note file will be hidden in the file explorer; the contents of the folder will stay visible.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideNotesInExplorer).onChange(async (value) => {
      this.plugin.settings.hideNotesInExplorer = value;
      await this.plugin.saveSettings();
      this.plugin.updateExplorerStyles();
    }));
    new import_obsidian.Setting(containerEl).setName("Hide folder contents in sidebar").setDesc("When enabled, folder contents will be hidden in the sidebar when a folder dashboard exists.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideFolderContents).onChange(async (value) => {
      this.plugin.settings.hideFolderContents = value;
      await this.plugin.saveSettings();
      this.plugin.updateFolderDisplay();
    }));
    new import_obsidian.Setting(containerEl).setName("Creation trigger").setDesc("Choose how to trigger folder dashboard creation when clicking on folders").addDropdown((dropdown) => dropdown.addOption("command-only", "Command only").addOption("alt-click", "Alt + Click").addOption("ctrl-click", "Ctrl + Click").addOption("shift-click", "Shift + Click").setValue(this.plugin.settings.triggerMode).onChange(async (value) => {
      this.plugin.settings.triggerMode = value;
      await this.plugin.saveSettings();
      this.plugin.setupTriggerMode();
    }));
    containerEl.createEl("h3", { text: "Display Settings" });
    new import_obsidian.Setting(containerEl).setName("View Type").setDesc("Choose how folder contents are displayed in the dashboard.").addDropdown((dropdown) => dropdown.addOption("simple-list", "Simple List").addOption("card-view", "Card View").addOption("column-view", "Column View").setValue(this.plugin.settings.viewType).onChange(async (value) => {
      this.plugin.settings.viewType = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllDashboards();
    }));
    containerEl.createEl("h3", { text: "Metadata Settings" });
    new import_obsidian.Setting(containerEl).setName("Include frontmatter").setDesc("When enabled, displays frontmatter properties in file listings.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeFrontmatter).onChange(async (value) => {
      this.plugin.settings.includeFrontmatter = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllDashboards();
    }));
    new import_obsidian.Setting(containerEl).setName("Show file creation date").setDesc("Display creation date for each file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showFileCreationDate).onChange(async (value) => {
      this.plugin.settings.showFileCreationDate = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllDashboards();
    }));
    new import_obsidian.Setting(containerEl).setName("Show file modification date").setDesc("Display last modified date for each file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showFileModificationDate).onChange(async (value) => {
      this.plugin.settings.showFileModificationDate = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllDashboards();
    }));
    containerEl.createEl("h3", { text: "Advanced Settings" });
    new import_obsidian.Setting(containerEl).setName("Custom CSS").setDesc("Add custom CSS rules to adjust the dashboard appearance.").addTextArea((text) => text.setValue(this.plugin.settings.customCSS).onChange(async (value) => {
      this.plugin.settings.customCSS = value;
      await this.plugin.saveSettings();
      this.plugin.updateCustomCSS();
    })).setClass("custom-css-setting");
  }
};

// dashboard-manager.ts
var import_obsidian2 = require("obsidian");
var DashboardManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  initialize() {
    this.markAllDashboards();
    this.setupFolderClickHandling();
  }
  markAllDashboards() {
    this.app.workspace.onLayoutReady(() => {
      const files = this.app.vault.getMarkdownFiles();
      for (const file of files) {
        const folder = file.parent;
        if (folder && file.basename === folder.name) {
          this.markFolderWithDashboard(folder);
          this.markDashboardFile(file);
        }
      }
    });
  }
  setupFolderClickHandling() {
    this.plugin.registerDomEvent(document, "click", (evt) => {
      if (evt.altKey || evt.ctrlKey || evt.shiftKey)
        return;
      const target = evt.target;
      const folderTitleEl = target.closest(".nav-folder-title");
      if (!folderTitleEl)
        return;
      const folderPath = folderTitleEl.getAttribute("data-path");
      if (!folderPath)
        return;
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof import_obsidian2.TFolder))
        return;
      const dashboardPath = `${folderPath}/${folder.name}.md`;
      const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
      if (dashboardFile instanceof import_obsidian2.TFile) {
        evt.preventDefault();
        evt.stopPropagation();
        this.app.workspace.openLinkText(dashboardPath, "", false);
      }
    });
    this.plugin.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian2.TFile) {
        const folder = file.parent;
        if (folder && file.basename === folder.name) {
          this.markFolderWithDashboard(folder);
          this.markDashboardFile(file);
        }
      }
    }));
    this.plugin.registerEvent(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian2.TFile) {
        const folder = file.parent;
        if (folder && file.basename === folder.name) {
          this.unmarkFolderWithDashboard(folder);
        }
      }
    }));
  }
  markFolderWithDashboard(folder) {
    setTimeout(() => {
      var _a, _b;
      const folderEl = (_b = (_a = document.querySelector(`.nav-folder-title[data-path="${folder.path}"]`)) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.parentElement;
      if (folderEl) {
        folderEl.addClass("has-dashboard");
      }
    }, 100);
  }
  unmarkFolderWithDashboard(folder) {
    setTimeout(() => {
      var _a, _b;
      const folderEl = (_b = (_a = document.querySelector(`.nav-folder-title[data-path="${folder.path}"]`)) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.parentElement;
      if (folderEl) {
        folderEl.removeClass("has-dashboard");
      }
    }, 100);
  }
  markDashboardFile(file) {
    setTimeout(() => {
      var _a;
      const fileEl = (_a = document.querySelector(`.nav-file-title[data-path="${file.path}"]`)) == null ? void 0 : _a.parentElement;
      if (fileEl) {
        fileEl.addClass("is-dashboard-file");
      }
    }, 100);
  }
  updateVisibility() {
    if (this.plugin.settings.hideNotesInExplorer) {
      document.body.style.setProperty("--dynamic-folder-dash-file-display", "none");
    } else {
      document.body.style.setProperty("--dynamic-folder-dash-file-display", "block");
    }
    if (this.plugin.settings.hideFolderContents) {
      document.body.style.setProperty("--dynamic-folder-dash-display", "none");
    } else {
      document.body.style.setProperty("--dynamic-folder-dash-display", "block");
    }
  }
};

// main.ts
var DynamicFolderDash = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.dashboardManager = new DashboardManager(this.app, this);
    this.dashboardManager.initialize();
    this.dashboardManager.updateVisibility();
    this.setupTriggerMode();
    this.addCommand({
      id: "create-folder-dashboard",
      name: "Create folder dashboard",
      callback: () => {
        const folder = this.getActiveFolderFromExplorer();
        if (folder) {
          this.createFolderDashboard(folder);
        }
      }
    });
    this.customStyleEl = document.createElement("style");
    document.head.appendChild(this.customStyleEl);
    this.updateCustomCSS();
    this.addSettingTab(new DynamicFolderDashSettingTab(this.app, this));
  }
  updateExplorerStyles() {
    this.dashboardManager.updateVisibility();
  }
  updateFolderDisplay() {
    this.dashboardManager.updateVisibility();
  }
  onunload() {
    if (this.customStyleEl && this.customStyleEl.parentNode) {
      this.customStyleEl.parentNode.removeChild(this.customStyleEl);
    }
    if (this.folderClickHandler) {
      document.removeEventListener("click", this.folderClickHandler, true);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  updateCustomCSS() {
    this.customStyleEl.textContent = this.settings.customCSS;
  }
  getNavFolderEl(path) {
    var _a;
    const fileExplorer = this.app.workspace.getLeavesOfType("file-explorer")[0];
    if (!fileExplorer)
      return null;
    const folderEl = (_a = fileExplorer.view.containerEl.querySelector(`.nav-folder-title[data-path="${path}"]`)) == null ? void 0 : _a.parentElement;
    return folderEl || null;
  }
  async createFolderDashboardForActiveFolder() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return;
    const folder = activeFile.parent;
    if (folder) {
      await this.createFolderDashboard(folder);
    }
  }
  async createFolderDashboard(folder) {
    const dashboardName = `${folder.name}.md`;
    const dashboardPath = `${folder.path}/${dashboardName}`;
    const existingDashboard = this.app.vault.getAbstractFileByPath(dashboardPath);
    if (existingDashboard instanceof import_obsidian3.TFile) {
      await this.updateFolderDashboard(folder, existingDashboard);
      await this.app.workspace.getLeaf().openFile(existingDashboard);
      return;
    }
    const content = await this.generateDashboardContent(folder);
    const newDashboard = await this.app.vault.create(dashboardPath, content);
    await this.app.workspace.getLeaf().openFile(newDashboard);
  }
  async updateFolderDashboard(folder, dashboardFile) {
    const content = await this.generateDashboardContent(folder);
    await this.app.vault.modify(dashboardFile, content);
  }
  async generateDashboardContent(folder) {
    const viewType = this.settings.viewType;
    let content = `# ${folder.name}

`;
    content += `*This is a dynamic dashboard for the "${folder.name}" folder.*

`;
    content += `<div class="dynamic-folder-dash ${viewType}">
`;
    switch (viewType) {
      case "card-view":
        content += await this.generateCardView(folder);
        break;
      case "column-view":
        content += await this.generateColumnView(folder);
        break;
      case "simple-list":
      default:
        content += await this.generateSimpleListView(folder);
        break;
    }
    content += `</div>`;
    return content;
  }
  async generateSimpleListView(folder) {
    let content = "";
    const subfolders = folder.children.filter((child) => child instanceof import_obsidian3.TFolder);
    if (subfolders.length > 0) {
      content += `<h2>Subfolders</h2>
<ul>`;
      for (const subfolder of subfolders) {
        content += `<li>\u{1F4C1} <a class="internal-link" href="${subfolder.path}/${subfolder.name}" data-href="${subfolder.path}/${subfolder.name}">${subfolder.name}</a></li>
`;
      }
      content += `</ul>
`;
    }
    const files = folder.children.filter((child) => child instanceof import_obsidian3.TFile && child.name !== `${folder.name}.md`);
    if (files.length > 0) {
      content += `<h2>Files</h2>
<ul>`;
      for (const file of files) {
        if (file instanceof import_obsidian3.TFile) {
          const fileName = file.basename;
          content += `<li>\u{1F4C4} <a class="internal-link" href="${file.path}" data-href="${file.path}">${fileName}</a>${await this.getFileMetadataHTML(file)}</li>
`;
        }
      }
      content += `</ul>`;
    }
    return content;
  }
  async generateCardView(folder) {
    let content = "";
    const allItems = folder.children;
    for (const item of allItems) {
      if (item instanceof import_obsidian3.TFolder) {
        content += `<div class="card folder-card">
                    <div class="card-title">\u{1F4C1} <a class="internal-link" href="${item.path}/${item.name}" data-href="${item.path}/${item.name}">${item.name}</a></div>
                    <div class="card-content">Folder with ${item.children.length} items</div>
                </div>
`;
      } else if (item instanceof import_obsidian3.TFile && item.name !== `${folder.name}.md`) {
        const file = item;
        const fileIcon = this.getFileIcon(file);
        content += `<div class="card file-card">
                    <div class="card-title">${fileIcon} <a class="internal-link" href="${file.basename}" data-href="${file.basename}">${file.basename}</a></div>
                    ${await this.generateFileMetadata(file)}
                </div>
`;
      }
    }
    return content;
  }
  async generateColumnView(folder) {
    let content = "";
    const subfolders = folder.children.filter((child) => child instanceof import_obsidian3.TFolder);
    if (subfolders.length > 0) {
      content += `<div class="column folders-column">
                <h3>Folders</h3>
                <ul>`;
      for (const subfolder of subfolders) {
        content += `<li>\u{1F4C1} <a class="internal-link" href="${subfolder.path}/${subfolder.name}" data-href="${subfolder.path}/${subfolder.name}">${subfolder.name}</a></li>
`;
      }
      content += `</ul>
            </div>
`;
    }
    const files = folder.children.filter((child) => child instanceof import_obsidian3.TFile && child.name !== `${folder.name}.md`);
    if (files.length > 0) {
      content += `<div class="column files-column">
                <h3>Files</h3>
                <ul>`;
      for (const file of files) {
        if (file instanceof import_obsidian3.TFile) {
          const fileName = file.basename;
          content += `<li>\u{1F4C4} <a class="internal-link" href="${fileName}" data-href="${fileName}">${fileName}</a>${await this.getFileMetadataHTML(file)}</li>
`;
        }
      }
      content += `</ul>
            </div>
`;
    }
    return content;
  }
  async generateFileMetadata(file) {
    let metadata = '<div class="file-metadata">';
    if (this.settings.showFileCreationDate) {
      const created = file.stat.ctime;
      const createdDate = new Date(created).toLocaleDateString();
      metadata += `<div class="file-created">Created: ${createdDate}</div>`;
    }
    if (this.settings.showFileModificationDate) {
      const modified = file.stat.mtime;
      const modifiedDate = new Date(modified).toLocaleDateString();
      metadata += `<div class="file-modified">Modified: ${modifiedDate}</div>`;
    }
    if (this.settings.includeFrontmatter) {
      const frontmatter = await this.getFrontmatter(file);
      if (frontmatter && Object.keys(frontmatter).length > 0) {
        metadata += `<div class="file-frontmatter">`;
        for (const [key, value] of Object.entries(frontmatter)) {
          metadata += `<div><span class="frontmatter-key">${key}:</span> ${value}</div>`;
        }
        metadata += `</div>`;
      }
    }
    metadata += "</div>";
    return metadata;
  }
  async generateFileListItem(file, includeMetadata = true) {
    const fileIcon = this.getFileIcon(file);
    let item = `- ${fileIcon} [[${file.basename}]]`;
    if (includeMetadata && (this.settings.showFileCreationDate || this.settings.showFileModificationDate)) {
      item += " ";
      if (this.settings.showFileCreationDate) {
        const created = file.stat.ctime;
        const createdDate = new Date(created).toLocaleDateString();
        item += `(Created: ${createdDate}) `;
      }
      if (this.settings.showFileModificationDate) {
        const modified = file.stat.mtime;
        const modifiedDate = new Date(modified).toLocaleDateString();
        item += `(Modified: ${modifiedDate})`;
      }
    }
    item += "\n";
    return item;
  }
  getFileIcon(file) {
    const ext = file.extension.toLowerCase();
    switch (ext) {
      case "md":
        return "\u{1F4C4}";
      case "pdf":
        return "\u{1F4D1}";
      case "jpg":
      case "jpeg":
      case "png":
      case "gif":
        return "\u{1F5BC}\uFE0F";
      case "mp3":
      case "wav":
      case "ogg":
        return "\u{1F3B5}";
      default:
        return "\u{1F4C4}";
    }
  }
  handleFileChange(file) {
    const parentFolder = file.parent;
    if (!parentFolder)
      return;
    const dashboardPath = `${parentFolder.path}/${parentFolder.name}.md`;
    const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
    if (dashboardFile instanceof import_obsidian3.TFile) {
      this.updateFolderDashboard(parentFolder, dashboardFile);
    }
  }
  handleFileRename(file, oldPath) {
    this.handleFileChange(file);
    if (file instanceof import_obsidian3.TFolder) {
      const dashboardPath = `${file.path}/${file.name}.md`;
      const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
      if (dashboardFile instanceof import_obsidian3.TFile) {
        this.updateFolderDashboard(file, dashboardFile);
      }
    }
  }
  async handleInternalLinkClick(target, evt) {
    const href = target.getAttribute("href");
    if (!href)
      return;
    let path = decodeURI(href);
    if (path.startsWith("/")) {
      path = path.substring(1);
    }
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian3.TFolder) {
      evt.preventDefault();
      await this.createFolderDashboard(file);
      return;
    }
    const potentialFolderPath = path.substring(0, path.lastIndexOf("/"));
    const folderName = path.substring(path.lastIndexOf("/") + 1);
    if (potentialFolderPath && folderName && potentialFolderPath.endsWith(folderName)) {
      const folder = this.app.vault.getAbstractFileByPath(potentialFolderPath);
      if (folder instanceof import_obsidian3.TFolder) {
        evt.preventDefault();
        await this.createFolderDashboard(folder);
        return;
      }
    }
  }
  async updateAllDashboards() {
    const dashboards = this.app.vault.getMarkdownFiles().filter((file) => {
      const folder = file.parent;
      return folder && file.basename === folder.name;
    });
    for (const dashboard of dashboards) {
      const folder = dashboard.parent;
      if (folder) {
        await this.updateFolderDashboard(folder, dashboard);
      }
    }
  }
  async getFrontmatter(file) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (match && match[1]) {
        const yaml = match[1];
        const properties = {};
        const lines = yaml.split("\n");
        for (const line of lines) {
          const keyValueMatch = line.match(/(.+?)\s*:\s*(.*)/);
          if (keyValueMatch) {
            const [, key, value] = keyValueMatch;
            properties[key.trim()] = value.trim();
          }
        }
        return properties;
      }
    } catch (error) {
      console.error(`Error parsing frontmatter for ${file.path}:`, error);
    }
    return null;
  }
  setupTriggerMode() {
    if (this.folderClickHandler) {
      document.removeEventListener("click", this.folderClickHandler, true);
    }
    if (this.settings.triggerMode !== "command-only") {
      this.folderClickHandler = this.createFolderClickHandler();
      document.addEventListener("click", this.folderClickHandler, true);
    }
  }
  createFolderClickHandler() {
    return (event) => {
      const modifierActive = this.settings.triggerMode === "alt-click" && event.altKey || this.settings.triggerMode === "ctrl-click" && event.ctrlKey || this.settings.triggerMode === "shift-click" && event.shiftKey;
      if (!modifierActive)
        return;
      const target = event.target;
      const folderTitleEl = target.closest(".nav-folder-title");
      if (!folderTitleEl)
        return;
      const folderPath = folderTitleEl.getAttribute("data-path");
      if (!folderPath)
        return;
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof import_obsidian3.TFolder))
        return;
      event.preventDefault();
      event.stopPropagation();
      this.createFolderDashboard(folder);
    };
  }
  async setupFolderClickInterception() {
    this.registerDomEvent(document, "click", (evt) => {
      if (evt.altKey || evt.ctrlKey || evt.shiftKey)
        return;
      const target = evt.target;
      const folderTitleEl = target.closest(".nav-folder-title");
      if (!folderTitleEl)
        return;
      const folderPath = folderTitleEl.getAttribute("data-path");
      if (!folderPath)
        return;
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof import_obsidian3.TFolder))
        return;
      const dashboardPath = `${folderPath}/${folder.name}.md`;
      const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
      if (dashboardFile instanceof import_obsidian3.TFile) {
        evt.preventDefault();
        evt.stopPropagation();
        this.app.workspace.openLinkText(dashboardPath, "", false);
      }
    });
  }
  async getFileMetadataHTML(file) {
    let metadata = "";
    if (this.settings.showFileCreationDate || this.settings.showFileModificationDate) {
      metadata += ' <span class="file-metadata">';
      if (this.settings.showFileCreationDate) {
        const created = file.stat.ctime;
        const createdDate = new Date(created).toLocaleDateString();
        metadata += `(Created: ${createdDate}) `;
      }
      if (this.settings.showFileModificationDate) {
        const modified = file.stat.mtime;
        const modifiedDate = new Date(modified).toLocaleDateString();
        metadata += `(Modified: ${modifiedDate})`;
      }
      metadata += "</span>";
    }
    return metadata;
  }
  markDashboardFiles() {
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const folder = file.parent;
      if (folder && file.basename === folder.name) {
        this.markFileInExplorer(file);
      }
    }
  }
  markFileInExplorer(file) {
    setTimeout(() => {
      var _a;
      const fileEl = (_a = document.querySelector(`.nav-file-title[data-path="${file.path}"]`)) == null ? void 0 : _a.parentElement;
      if (fileEl) {
        fileEl.addClass("is-dashboard-file");
      }
    }, 100);
  }
  getActiveFolderFromExplorer() {
    const fileExplorer = this.app.workspace.getLeavesOfType("file-explorer")[0];
    if (!fileExplorer)
      return null;
    const selectedEl = fileExplorer.view.containerEl.querySelector(".nav-folder.is-active");
    if (!selectedEl)
      return null;
    const folderTitleEl = selectedEl.querySelector(".nav-folder-title");
    if (!folderTitleEl)
      return null;
    const folderPath = folderTitleEl.getAttribute("data-path");
    if (!folderPath)
      return null;
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!(folder instanceof import_obsidian3.TFolder))
      return null;
    return folder;
  }
};
